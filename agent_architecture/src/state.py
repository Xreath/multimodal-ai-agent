"""
Agent State — State definition for the LangGraph graph.

In LangGraph, state is the shared data among all nodes in the graph.
Each node reads, processes, and updates the state. This is the "shared blackboard" pattern.

╔══════════════════════════════════════════════════════════════════╗
║  LangGraph State Concept                                        ║
║                                                                  ║
║  State = TypedDict (type-safe dict)                             ║
║                                                                  ║
║  When each node runs:                                           ║
║  1. Receives a copy of the state (read)                         ║
║  2. Performs operations                                         ║
║  3. Returns updated fields (partial update)                     ║
║                                                                  ║
║  Important: Nodes DO NOT return the ENTIRE state,               ║
║  only the fields they changed → these are merged                ║
╚══════════════════════════════════════════════════════════════════╝

Interview note:
- LangGraph updates state via "reducer" functions
- Annotated[list, operator.add] → append semantics for lists
- This is inspired by the Redux/Flux pattern
- State immutability: each node returns new values, old state is preserved
- Checkpointing: a snapshot of the state can be taken at each step (for rollback)
"""

import operator
from typing import Annotated, TypedDict, Optional, Literal


class AgentState(TypedDict):
    """
    State of the Multi-Modal Agent.

    This state is shared among all nodes in the graph.
    Each field can be thought of as a "channel".

    Explanation of Annotated[list, operator.add]:
    - Normal dict update: {"messages": [new]} → DELETES old messages
    - With operator.add: {"messages": [new]} → APPENDS to old messages
    - This is critical for accumulative data like conversation history
    """

    # ─── User Input ───────────────────────────────────────
    user_query: str                          # User's original query
    image_path: Optional[str]                # Image to analyze (optional)
    audio_path: Optional[str]                # Audio input (for Voice node, optional)

    # ─── Planner Output ─────────────────────────────────────────
    plan: list[str]                          # List of steps generated by the Planner
    current_step: int                        # Which step we are currently at (0-indexed)

    # ─── Tool Results ──────────────────────────────────────────
    # operator.add → each tool result is APPENDED to the list (not overwritten)
    tool_results: Annotated[list[dict], operator.add]

    # ─── CV Pipeline Result ──────────────────────────────────────
    cv_result: Optional[dict]                # CV analysis produced by the Vision node

    # ─── Voice Node Outputs ─────────────────────────────────────
    transcription: Optional[str]             # Text output from Whisper ASR

    # ─── Search Node Outputs ────────────────────────────────────
    # operator.add → each search result is appended accumulatively
    search_results: Annotated[list[dict], operator.add]

    # ─── Memory Node Outputs ────────────────────────────────────
    memory_context: Optional[str]            # RAG-style context from VectorMemory

    # ─── Message History ───────────────────────────────────────────
    # operator.add → each message is appended accumulatively
    messages: Annotated[list[dict], operator.add]

    # ─── Reasoning / Final Answer ─────────────────────────────────
    reasoning: Optional[str]                 # Analysis produced by the Reasoner
    final_answer: Optional[str]              # Answer to be given to the user

    # ─── Control Flow ───────────────────────────────────────────
    next_action: Optional[str]               # Router's decision: "vision", "reason", "respond", ...
    needs_human_approval: bool               # Human-in-the-loop flag
    iteration_count: int                     # Loop counter (infinite loop protection)
    max_iterations: int                      # Maximum loop limit

    # ─── Evaluation ───────────────────────────────────────────
    evaluation_score: Optional[float]        # Quality score given by Evaluator (0-1)
    evaluation_feedback: Optional[str]       # Feedback from Evaluator


def create_initial_state(
    user_query: str,
    image_path: Optional[str] = None,
    audio_path: Optional[str] = None,
    max_iterations: int = 5
) -> AgentState:
    """
    Creates the initial state for a new agent run.

    Args:
        user_query: The user's question
        image_path: Path to the image to analyze
        audio_path: Path to the audio file
        max_iterations: Maximum iterations (infinite loop protection)

    Returns:
        Initial state dictionary
    """
    return {
        "user_query": user_query,
        "image_path": image_path,
        "audio_path": audio_path,
        "plan": [],
        "current_step": 0,
        "tool_results": [],
        "cv_result": None,
        "transcription": None,
        "search_results": [],
        "memory_context": None,
        "messages": [{
            "role": "user",
            "content": user_query
        }],
        "reasoning": None,
        "final_answer": None,
        "next_action": None,
        "needs_human_approval": False,
        "iteration_count": 0,
        "max_iterations": max_iterations,
        "evaluation_score": None,
        "evaluation_feedback": None,
    }
